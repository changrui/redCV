Red [	Title:   "Red Computer Vision: Image Processing"	Author:  "Francois Jouen"	File: 	 %imgproc.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]; ********* Image Convolution **********rcvConvole: routine [src1 [image!] kernel [block!] factor [float!] bias [float!] return: [image!]	/local 		dst 		stride1 		stride2 		bmp1 		bmpDst 		data1 		dataDst 		w 		h		x 		y 		pos		a		r		g		b		fa		fr		fg		fb		imx		imy		f		value		filterX 		filterY 		i 		j 		index 		base][    dst: as red-image! stack/push*        ;-- create an new image slot    image/copy src1 dst null yes null    stride1: 0    stride2: 0    bmp1: OS-image/lock-bitmap as-integer src1/node no    bmpDst: OS-image/lock-bitmap as-integer dst/node yes        data1: OS-image/get-data bmp1 :stride1       dataDst: OS-image/get-data bmpDst :stride2    w: IMAGE_WIDTH(src1/size)    h: IMAGE_HEIGHT(src1/size)    ; get Kernel dimension (e.g. 3, 5 ...)    filterX: float/to-integer (sqrt integer/to-float (block/rs-length? kernel))	filterY: filterX    ; for image    x: 0    y: 0  		    while [y < h][        while [x < w][        	fr: 0.0     		fg: 0.0   			fb: 0.0    		fa: 0.0            ; multiply every value of the filter with corresponding image pixel            			j: 0			index: 0			; kernel is passed as a pointer 			base: block/rs-head kernel ; get pointer adress of the kernel first value			value: base            while [j < filterY][            	i: 0        		while [i < filterX][        			imx:  (x + (i - (filterx / 2)) + w ) % w ; OK         			imy:  (y + (j - (filtery / 2)) + h ) % h ; OK        			pos: stride1 >> 2 * imy + imx + 1        			;OK for data        			a: data1/pos >>> 24            		r: data1/pos and 00FF0000h >> 16            		g: data1/pos and FF00h >> 8            			b: data1/pos and FFh            			;get kernel values OK        			index: j * filterX + i + 1        			f: as red-float! value        			; calculate weighted values        			fr: fr + ((integer/to-float r) * f/value)        			fg: fg + ((integer/to-float g) * f/value)        			fb: fb + ((integer/to-float b) * f/value)        			value: base + index        			i: i + 1        		]        		i: 0       			j: j + 1      		]    		j: 0    		       		;truncate values smaller than zero and larger than 255    		             r: float/to-integer (fr  * factor + bias)             g: float/to-integer (fg  * factor + bias)             b: float/to-integer (fb  * factor + bias)                        if r < 0 [r: 0]            if r > 255 [r: 255]            if g < 0 [g: 0]            if g > 255 [g: 255]            if b < 0 [b: 0]            if b > 255 [b: 255]                        dataDst/pos: ((a << 24) OR (r << 16 ) OR (g << 8) OR b)	            x: x + 1        ]        x: 0        y: y + 1    ]        OS-image/unlock-bitmap as-integer src1/node bmp1    OS-image/unlock-bitmap as-integer dst/node bmpDst	as red-image! stack/set-last as cell! dst            ;-- return new image]
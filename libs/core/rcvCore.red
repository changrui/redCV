Red [	Title:   "Red Computer Vision: Core functions"	Author:  "Francois Jouen"	File: 	 %rcvCore.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]{To know: loaded images by red are in ARGB format (a tuple )Images are 8-bit [0..255] and internally uses bytes as a binary stringActually Red can't create 1 2 or 3 channels images : only 4 channelsActually Red can't create 16-bit (0..65536) 32-bit or 64-bit (0.0..1.0) imagespixel >>> 24				: Alphapixel and 00FF0000h >> 16 	: Redpixel and FF00h >> 8		: Greenpixel and FFh				: Blue}; ********* image conversion ********** rcv2Gray: function [ src [image!]  dst [image!] /average /luminosity /lightness return: [image!]"Converts RGB image to Grayscale" ][	case [		average 	[rcvConvert src dst 1]		luminosity 	[rcvConvert src dst 111]		lightness 	[rcvConvert src dst 112]	]]rcv2BGRA: function [src [image!] dst [image!] "Converts RGBA => BGRA"][	rcvConvert src dst 2 ]rcv2RGBA: function [src [image!] dst [image!]"Converts BGRA => RGBA"][	rcvConvert src dst 3 ]rcv2BW: function [src [image!] dst [image!]"Converts RGB image => Black and White"][	rcvConvert src dst 4  ; then binarization of the gray image with 128.128.128.0 as threshold]rcvSplit: function[src [image!] dst [image!]/red /green /blue "Split source image in separate channels"][	case [		red 	[rcvChannel src dst 1]		green 	[rcvChannel src dst 2]		blue 	[rcvChannel src dst 3]	]]; similar to NOT imagercvInvert: function [source [image!] dst [image!]"Invert image = rcvNot"][	img: copy source	dst/rgb:  complement source/rgb ]; ********** Math Operators on image **********rcvAdd: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 1]rcvSub: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 2]rcvMul: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 3]rcvDiv: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 4] rcvMod: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 5] rcvRem: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 6] rcvAbsDiff: function [src1 [image!] src2 [image!] dst [image!]][	rcvMath src1 src2 dst 7] ; ********** Math operators with scalar (tuple or integer) *********rcvAddS: function [src [image!] dst [image!] val [integer!] "Adds value to image"][	rcvMathS src dst val 1]rcvSubS: function [src [image!] dst [image!] val [integer!]"Substracts value to image"][	rcvMathS src dst val 2	]rcvMulS: function [src [image!] dst [image!] val [integer!] "Multiplies image by value"][	rcvMathS src dst val 3]rcvDivS: function [src [image!] dst [image!] val [integer!] "Divides image by value"][	rcvMathS src dst val 4]rcvModS: function [src [image!] dst [image!] val [integer!] "Modulo image value"][	rcvMathS src dst val 5]rcvRemS: function [src [image!] dst [image!] val [integer!] "Remainder image value"][	rcvMathS src dst val 6]rcvAddT: function [src [image!] dst [image!] val [tuple!] "Adds value to image"][	rcvMathT src dst val 1]rcvSubT: function [src [image!] dst [image!] val [tuple!]"Substracts value to image"][	rcvMathT src dst val 2	]rcvMulT: function [src [image!] dst [image!] val [tuple!] "Multiplies image by value"][	rcvMathT src dst val 3]rcvDivT: function [src [image!] dst [image!] val [tuple!] "Divides image by value"][	rcvMathT src dst val 4]rcvModT: function [src [image!] dst [image!] val [tuple!] "Modulo image  value"][	rcvMathT src dst val 5]rcvRemT: function [src [image!] dst [image!] val [tuple!] "Remainder image value"][	rcvMathT src dst val 6]rcvPow: function [src [image!]  dst [image!] val [integer!] "Power image value"][	rcvMathS src dst val 7]rcvLSH: function [src [image!] dst [image!]val [integer!] "Left shift"][	rcvMathS src dst val 8]rcvRSH: function [src [image!] dst [image!] val [integer!] "Right Shift"][	rcvMathS src dst val 9]rcvSQR: function [src [image!] dst [image!] val [integer!]  " Image square root"][	rcvMathS src dst val 10]; ************* Logical operator ***************************rcvAND: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 1]rcvOR: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 2]rcvXOR: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2  dst 3]rcvNAND: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 4]rcvNOR: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 5]rcvNXOR: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 6]rcvMIN: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 7]rcvMAX: function [src1 [image!] src2 [image!] dst [image!]] [	rvcLogical src1 src2 dst 8]; ************ logical operators and scalar (tuple!) on images **********; TBT none or rcvReleaseImagercvANDS: function [src [image!] dst [image!] value [tuple!] return: [image!]][	tmp: make image! reduce[src/size value]	rvcLogical src tmp dst 1	tmp: none]rcvORS: function [src [image!] dst [image!] value [tuple!] return: [image!]][	tmp: make image! reduce[src/size value]	rvcLogical src tmp dst 2	tmp: none]rcvXORS: function [src [image!] dst [image!] value [tuple!] return: [image!]][	tmp: make image! reduce[src/size value]	rvcLogical src tmp dst 3	tmp: none]
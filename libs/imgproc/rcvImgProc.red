Red [	Title:   "Red Computer Vision: Image Processing"	Author:  "Francois Jouen"	File: 	 %rcvImgProc.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]; ********* Image Random **********;TBI_rcvRandom: routine [size [pair!] value [tuple!] return: [image!]	/local 		dst 		stride 		bmpDst 		dataDst 		w 		x 		y 		h 		pos		tp		sz		r		g		b		a][    dst: as red-image! stack/push*        ;-- create an new image slot    sz: as red-pair! size    stride: 0          bmpDst: OS-image/lock-bitmap as-integer dst/node yes        dataDst: OS-image/get-data bmpDst :stride    w: sz/x    h: sz/y    x: 0    y: 0    tp: as red-tuple! value    while [y < h][        while [x < w][            pos: stride >> 2 * y + x + 1            a: 0 r: 0 g: 0 b: 0            dataDst/pos: ((a << 24) OR (r << 16 ) OR (g << 8) OR b)            ;dataDst/pos: as-integer tuple/random tp true false false            x: x + 1        ]        x: 0        y: y + 1    ]    OS-image/unlock-bitmap as-integer dst/node bmpDst	as red-image! stack/set-last as cell! dst            ;-- return new image]; ********* Image Convolution **********{The 2D convolution operation isn't extremely fast, unless you use small filters. We'll usually be using 3x3 or 5x5 filters. There are a few rules about the filter:Its size has to be uneven, so that it has a center, for example 3x3, 5x5, 7x7 or 9x9 are ok. The sum of all elements of the filter should be 1 if you want the resulting image to have the same brightness as the originalIf the sum of the elements is larger than 1, the result will be a brighter imageIf it's smaller than 1, a darker image. If the sum is 0, the resulting image isn't necessarily completely black, but it'll be very darkApart from using a kernel matrix, it also has a multiplier factor and a bias. After applying the filter, the factor will be multiplied with the result, and the bias added to it. So if you have a filter with an element 0.25 in it, but the factor is set to 2, all elements of the filter are  multiplied by two so that element 0.25 is actually 0.5. The bias can be used if you want to make the resulting image brighter. }rcvConvole: routine [src1 [image!] kernel [block!] factor [float!] bias [float!] return: [image!]	/local 		dst 		stride1 		stride2 		bmp1 		bmpDst 		data1 		dataDst 		w 		h		x 		y 		pos		r		g		b		a		fr		fg		fb		imx		imy		f		value		filterX 		filterY 		i 		j 		index 		base][    dst: as red-image! stack/push*        ;-- create an new image slot    image/copy src1 dst null yes null    stride1: 0    stride2: 0    bmp1: OS-image/lock-bitmap as-integer src1/node no    bmpDst: OS-image/lock-bitmap as-integer dst/node yes        data1: OS-image/get-data bmp1 :stride1       dataDst: OS-image/get-data bmpDst :stride2    w: IMAGE_WIDTH(src1/size)    h: IMAGE_HEIGHT(src1/size)    ; get Kernel dimension (e.g. 3, 5 ...)    filterX: float/to-integer (sqrt integer/to-float (block/rs-length? kernel))	filterY: filterX	; kernel is passed as a pointer 	base: block/rs-head kernel ; get pointer adress of the kernel first value    ; for image    x: 0    y: 0  	    while [y < h][        while [x < w][        	fr: 0.0     		fg: 0.0   			fb: 0.0            ; multiply every value of the filter with corresponding image pixel            			j: 0			index: 0						value: base            while [j < filterY][            	i: 0        		while [i < filterX][        			imx:  (x + (i - (filterx / 2)) + w ) % w ; OK pixel (-1, -1) will correctly become pixel (w-1, h-1)        			imy:  (y + (j - (filtery / 2)) + h ) % h ; OK pixel (-1, -1) will correctly become pixel (w-1, h-1).        			pos: stride1 >> 2 * imy + imx + 1        			;OK for data        			a: data1/pos >>> 24        			r: data1/pos and 00FF0000h >> 16            		g: data1/pos and FF00h >> 8            			b: data1/pos and FFh            			;get kernel values OK        			index: j * filterX + i + 1        			f: as red-float! value        			; calculate weighted values        			fr: fr + ((integer/to-float r) * f/value)        			fg: fg + ((integer/to-float g) * f/value)        			fb: fb + ((integer/to-float b) * f/value)        			value: base + index        			i: i + 1        		]        		i: 0       			j: j + 1      		]    		j: 0    		       		            r: float/to-integer (fr  * factor + bias)             g: float/to-integer (fg  * factor + bias)             b: float/to-integer (fb  * factor + bias)            ;truncate values smaller than zero and larger than 255            if r < 0 [r: 0]            if r > 255 [r: 255]            if g < 0 [g: 0]            if g > 255 [g: 255]            if b < 0 [b: 0]            if b > 255 [b: 255]                        dataDst/pos: ((a << 24) OR (r << 16 ) OR (g << 8) OR b)	            x: x + 1        ]        x: 0        y: y + 1    ]        OS-image/unlock-bitmap as-integer src1/node bmp1    OS-image/unlock-bitmap as-integer dst/node bmpDst	as red-image! stack/set-last as cell! dst            ;-- return new image]
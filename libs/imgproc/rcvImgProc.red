Red [	Title:   "Red Computer Vision: Image Processing"	Author:  "Francois Jouen"	File: 	 %rcvImgProc.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]#include %rcvImgProcRoutines.red; ************ Color space conversions **********rcvRGB2XYZ: function [src [image!] dst [image!]"BGR to CIE XYZ color conversion"] [	_rcvRGBXYZ src dst] rcvXYZ2RGB: function [src [image!] dst [image!]"CIE XYZ to RBG color conversion"] [	_rcvXYZRGB src dst] ; ************ image transform **********rcvFlip: function [src [image!] dst [image!] /horizontal /vertical /both return: [image!]"Left Right, Up down or both directions flip"][	case [		horizontal 	[_rcvFlipHV src dst 1]		vertical 	[_rcvFlipHV src dst 2]		both		[_rcvFlipHV src dst 3]	]	]; ********* Image Convolution **********{The 2D convolution operation isn't extremely fast, unless you use small filters. We'll usually be using 3x3 or 5x5 filters. There are a few rules about the filter:Its size has to be uneven, so that it has a center, for example 3x3, 5x5, 7x7 or 9x9 are ok. The sum of all elements of the filter should be 1 if you want the resulting image to have the same brightness as the originalIf the sum of the elements is larger than 1, the result will be a brighter imageIf it's smaller than 1, a darker image. If the sum is 0, the resulting image isn't necessarily completely black, but it'll be very darkApart from using a kernel matrix, it also has a multiplier factor and a bias. After applying the filter, the factor will be multiplied with the result, and the bias added to it. So if you have a filter with an element 0.25 in it, but the factor is set to 2, all elements of the filter are  multiplied by two so that element 0.25 is actually 0.5. The bias can be used if you want to make the resulting image brighter. }rcvConvolve: function [src [image!] dst [image!] kernel [block!] factor [float!] delta [float!]"Convolves an image with the kernel"] [	_rcvConvolve src dst kernel factor delta]rcvFastConvolve: function [src [image!] dst [image!] channel [integer!] kernel [block!] factor [float!] delta [float!]"Convolves a 8-bit and 1-channelimage with the kernel"] [	_rcvFastConvolve src dst channel kernel factor delta]rcvFilter2D: function [src [image!] dst [image!] kernel [block!]  delta [integer!]"Basic convolution Filter"] [	_rcvFilter2D src dst kernel delta]	rcvFastFilter2D: function [src [image!] dst [image!] kernel [block!]"Faster convolution Filter"] [	_rcvFastFilter2D src dst kernel]rcvMakeGaussian: function [kSize [pair!] return: [block!]"Creates a gaussian uneven kernel"][  gaussian: copy []  n: kSize/x - 1 / 2  i: negate n  j: negate n    sum: 0.0  stdv: 1.0  r: s: 2.0 * (stdv * stdv)  while [j <= n] [  	while [i <= n] [  		r: square-root (i * i) + (j * j)  		append gaussian exp  ((negate(r * r) / s) / (pi * s))  		sum: sum + exp  ((negate(r * r) / s) / (pi * s))  		i: i + 1  	]  	i: negate n  	j: j + 1  ]  ; now normalize the kernel  i: 0  while [i < (kSize/x * kSize/y)] [  	gaussian/(i + 1): gaussian/(i + 1) / sum  	i: i + 1  ]   gaussian	]rcvGaussianFilter: function [src [image!] dst [image!] kernel [block!] delta [integer!]"Gaussian 2D Filter"] [	_rcvFilter2D src dst kernel delta]rcvResizeImage: function [src [image!] canvas iSize [pair!]/gaussian return: [pair!]"Resizes image and applies filter for Gaussian pyramidal resizing if required"][	tmpImg: rcvCloneImage src	case [		gaussian [			knl: rcvMakeGaussian 5x5			_rcvFilter2D tmpImg src knl 0		]	]	rcvReleaseImage tmpImg	canvas/size: iSize	src: to-image canvas	src/size]rcvSobel: function [src dst iSize [pair!] /mat /image"Direct Sobel Edges Detection"] [	case [		mat 	[_rcvSobelMat src dst iSize]		image	[			img1: rcvCreateImage iSize			img2: rcvCreateImage iSize			rcvConvolve src img1 [1.0 2.0 1.0 0.0 0.0 0.0 -1.0 -2.0 -1.0] 1.0 0.0			rcvConvolve src img2 [1.0 2.0 -1.0 2.0 0.0 -2.0 1.0 -2.0 -1.0] 1.0 0.0			rcvAdd img1 img2 dst			rcvReleaseImage img1			rcvReleaseImage img2		]	]]rcvRobert: function [src dst iSize [pair!] factor [float!] delta [float!] /mat /image"Robert's Cross Edges Detection"] [	case [		image	[				img1: rcvCreateImage iSize				img2: rcvCreateImage iSize				_rcvConvolve src img1 [0.0 1.0 -1.0 0.0] factor delta				_rcvConvolve src img2 [1.0 0.0 0.0 -1.0] factor delta				rcvAdd img1 img2 dst				rcvReleaseImage img1				rcvReleaseImage img2		]		mat		[				; pbs TBT				mat1: rcvCreateMat 'integer! 8 iSize				mat2: rcvCreateMat 'integer! 8 iSize				_rcvConvolveMat src mat1 iSize [0.0 1.0 -1.0 0.0] factor delta				_rcvConvolveMat src mat2 iSize [1.0 0.0 0.0 -1.0] factor delta				dst: mat1 + mat2				rcvReleaseMat mat1				rcvReleaseMat mat2			]	]	]
Red [	Title:   "Red Computer Vision: Red/System routines"	Author:  "Francois Jouen"	File: 	 %rcvSats.red	Tabs:	 4	Rights:  "Copyright (C) 2016 Francois Jouen. All rights reserved."	License: {		Distributed under the Boost Software License, Version 1.0.		See https://github.com/red/red/blob/master/BSL-License.txt	}]#include %rcvStatsRoutines.red;***************** STATISTICAL FUNCTIONS ***********************;****************** images and matrices  ***********************rcvCountNonZero: function [arr [image! vector!]return: [integer!]"Returns number of non zero values in image or matrix"][	t: type? arr	if t = image! 	[n: _rcvCount arr]	if t = vector!  [n: _rcvCountMat arr]	n]rcvSum: function [arr [image! vector!] return: [block!] /argb"Returns sum value of image or matrix as a block"][	t: type? arr	if t = image! 	[	v: _rcvMeanInt arr						a: v >>> 24    					r: v and 00FF0000h >> 16     					g: v and FF00h >> 8     					b: v and FFh    					sz: arr/size/x * arr/size/y    					sa: a * sz    					sr: r * sz    					sg: g * sz    					sb: b * sz    					either argb [blk: reduce [sa sr sg sb]] [blk: reduce [sr sg sb]]					]	if t = vector!  [sum: _rcvSumMat arr blk: reduce [sum]]	blk]rcvMean: function [arr [image! vector!] return: [tuple!] /argb"Returns mean value of image or matrix as a tuple"][	t: type? arr	if t = vector!  [m: _rcvMeanMat arr tp: make tuple! reduce [m]]	if t = image! 	[v: _rcvMeanInt arr					a: v >>> 24    				r: v and 00FF0000h >> 16     				g: v and FF00h >> 8     				b: v and FFh   					either argb [tp: make tuple! reduce [a r g b]] [tp: make tuple! reduce [r g b]]	]	tp]rcvSTD: function [arr [image! vector!] return: [tuple!] /argb"Returns standard deviation value of image or matrix as a tuple"][t: type? arr	if t = vector!  [m: _rcvStdMat arr tp: make tuple! reduce [m]]	if t = image! 	[v: _rcvStdInt arr					a: v >>> 24    				r: v and 00FF0000h >> 16     				g: v and FF00h >> 8     				b: v and FFh   					either argb [tp: make tuple! reduce [a r g b]] [tp: make tuple! reduce [r g b]]	]	tp]	rcvMedian: function [arr [image! vector!] return: [tuple!]"Returns median value of image or matrix as a tuple"][t: type? arr	if t = vector!  [mat: copy arr					 sort mat					 n: to integer! length? mat					 pos: to integer! ((n + 1) / 2)					 either odd? n  [pxl: make tuple! reduce [mat/(pos)]] 					 				[m1: mat/(pos) m2: mat/(pos + 1) pxl: make tuple! reduce [(m1 + m2) / 2]]	]	if t = image! 	[img: copy arr					 img/rgb: copy sort arr/rgb 					 n: to integer! (length? img/rgb) / 3 ; RGB channels only					 pos: to integer! ((n + 1) / 2)					 either odd? n [pxl: img/(pos)] [m1: img/(pos) m2: img/(pos + 1) pxl: (m1 + m2) / 2]	]	pxl]	rcvMinValue: function [arr [image! vector!] return: [tuple!]"Minimal value in image or matrix as a tuple"][t: type? arr	if t = vector!  [mat: copy arr					 sort mat					 pxl: make tuple! reduce [mat/1]	]	if t = image! 	[img: copy arr					 img/rgb: copy sort arr/rgb 					 pxl: img/1	]	pxl]	rcvMaxValue: function [arr [image! vector!] return: [tuple!]"Maximal value in image or matrix as a tuple"][	t: type? arr	if t = vector!  [mat: copy arr					 sort mat					 pxl: make tuple! reduce [last mat]	]	if t = image! 	[img: copy arr					 img/rgb: copy sort arr/rgb 					 pxl: last img	]	pxl]	rcvMinLoc: function [arr [image! vector!] arrSize [pair!]return: [pair!]"Finds global minimum location in array"][	loc: 0x0	ret: 0x0	t: type? arr	if t = vector! [ret: _rcvMinLocMat arr arrSize loc]	if t = image! [ret: _rcvMinLoc arr loc]	ret]rcvMaxLoc: function [arr [image! vector!] arrSize [pair!]return: [pair!]"Finds global maximum location in array"][	loc: 0x0	ret: 0x0	t: type? arr	if t = vector! [ret: _rcvMaxLocMat arr arrSize loc]	if t = image! [ret: _rcvMaxLoc arr loc]	ret]rcvHistogram: function [arr [image! vector!] return:  [vector!] /red /green /blue /alpha"Calculates array histogram"][	histo: make vector! 256	t: type? arr	if t = vector! [_rcvHistoMat arr histo]	if t = image! [		case [			red 	[_rcvHisto arr histo 1]			green 	[_rcvHisto arr histo 2]			blue 	[_rcvHisto arr histo 3]		]		]	histo]rcvRangeImage: function [source [image!] return: [tuple!]"Range value in Image as a tuple"][	img: copy source	n: to integer! (length? img/rgb) / 3 ; RGB channels only	img/rgb: copy sort source/rgb 	pxl1: img/1	pxl2: img/(n)	pxl2 - pxl1]rcvSortImage: function [source [image!] dst [image!]"Ascending image sorting"][	img: copy source	dst/rgb: copy sort source/rgb ]